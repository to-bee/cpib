program RSAExampleGallier(in isDebugout:bool)
global
  proc euclidExt(in copy a:int64, in copy b:int64, out copy var g:int64, out copy var u:int64, out copy var v:int64, out copy var uStr:int64, out copy var vStr:int64)
  global in
  local
    var gStr:int64;
    var q:int64
  do
    g init := a; gStr init := b;
    u init := 1; uStr init := 0;
    v init := 0; vStr init := 1;
    q init := -1;
    while gStr > 0
    do
      q := g divE gStr;
      g := g - q * gStr; call optDebugout(g);
      u := u - q * uStr; call optDebugout(u);
      v := v - q * vStr; call optDebugout(v);
      call swap(g, gStr);
      call swap(u, uStr);
      call swap(v, vStr)
    endwhile
  endproc;

  proc swap(inout ref var x:int64, inout ref var y:int64)
  local const h:int64
  do h init := x ; x := y ; y := h endproc;

  proc modInverse
    (in copy a:int64, in copy m:int64,
     out copy const exists:bool, out copy var aInv:int64)
  global in isDebugout
  local
    const g:int64;
    const u:int64;
    const uStr:int64;
    const vStr:int64
  do
    call euclidExt(m, a, g init, u init, aInv init, uStr init, vStr init);
    exists init := g = 1;
    aInv := aInv modE m
  endproc;

  fun powerDijkstra(x:int64, n:int32, m:int64) returns var p:int64
  global in isDebugout
  local
    var e:int32 ; var q:int64
  do
    e init := n; call optDebugout(e);
    q init := x; call optDebugout(q);
    p init := 1; call optDebugout(p);
    while e > 0
    do
      while e modE 2 = 0
      do
        e := e divE 2;       call optDebugout(e);
        q := (q * q) modE m; call optDebugout(q)
      endwhile;
      e := e - 1;          call optDebugout(e);
      p := (q * p) modE m; call optDebugout(p)
    endwhile
  endfun;

  proc optDebugout(in copy x:int64)
  global in isDebugout
  do if isDebugout then debugout x endif endproc;

  const pA:int64;
  const qA:int64;
  const mA:int64;
  const phiA:int64;
  const eA:int64;
  const exists:bool;
  const dA:int64;
  var y:int64;
  var x:int64;
  var ygStr:int64
do
  pA init := 12553000;
  qA init := 13007;
  mA init := pA * qA;
  phiA init := (pA - 1) * (qA - 1);
  eA init := 79921;
  call modInverse(eA, phiA, exists init, dA init);
  debugout exists; debugout dA;

  y init := 145387828;
  x init := powerDijkstra(y, toInt32(dA), mA); debugout x;
  yStr init := powerDijkstra(x, toInt32(eA), mA); debugout yStr = y;

  y := 47164891;
  x := powerDijkstra(y, toInt32(dA), mA); debugout x;
  yStr := powerDijkstra(x, toInt32(eA), mA); debugout yStr = y;

  y := 152020614;
  x := powerDijkstra(y, toInt32(dA), mA); debugout x;
  yStr := powerDijkstra(x, toInt32(eA), mA); debugout yStr = y;

  y := 27279275;
  x := powerDijkstra(y, toInt32(dA), mA); debugout x;
  yStr := powerDijkstra(x, toInt32(eA), mA); debugout yStr = y;

  y := 35356191;
  x := powerDijkstra(y, toInt32(dA), mA); debugout x;
  yStr := powerDijkstra(x, toInt32(eA), mA); debugout yStr = y
endprogram
