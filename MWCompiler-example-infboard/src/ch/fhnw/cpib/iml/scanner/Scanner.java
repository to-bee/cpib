package ch.fhnw.cpib.iml.scanner;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Random;

import ch.fhnw.cpib.iml.lib.Chr;
import ch.fhnw.cpib.iml.lib.Keyword;
import ch.fhnw.cpib.iml.scanner.attr.AttrStrVal;
import ch.fhnw.cpib.iml.scanner.exception.InvalidEscapeSequenceException;
import ch.fhnw.cpib.iml.scanner.exception.ScannerException;
import ch.fhnw.cpib.iml.scanner.exception.ScannerIOException;
import ch.fhnw.cpib.iml.scanner.exception.SyntaxException;
import ch.fhnw.cpib.iml.scanner.state.ScannerState;
import ch.fhnw.cpib.iml.scanner.state.StateCarriageReturn;

/**
 * This is a state machine, that is a scanner for IML.
 * The method {@link #scan(SourceCode)} performs the scanning.
 * Any instance that implements {@link SourceCode} can be used as input.
 */
public enum Scanner implements IPosition {
  SCANNER;

  private Scanner() {
    // Only one instance exists (singleton).
    // This constructor is used to initialize other classes,
    // which will also create some objects that are needed.

    // Load all relevant Classes :
    try {
      // Initialize all possible Attributes:
      for (final Entry<String, Terminal> entry : Terminal
          .getTerminalsWithAttribute().entrySet())
        Class.forName(entry.getValue().attrClass.getName());

      Class.forName(Symbol.class.getName());
      Class.forName(Keyword.class.getName());
      Class.forName(DistinctToken.class.getName());
      Class.forName(ScannerState.class.getName());
      Class.forName(Alias.class.getName());
    } catch (final Throwable e) {
      e.printStackTrace();
    }
  }

  /**
   * Scan any String, which holds IML code.
   *
   * @param source
   *          Source code (as String).
   * @return List of Tokens.
   * @throws ScannerException
   */
  public TokenList scan(final String source) throws ScannerException {
    this.reset();
    try (final StringSourceCode src = new StringSourceCode(source)) {
      return this.scan(src);
    } catch (final IOException e) {
      // Strings do not actually throw these...
      throw new RuntimeException(e);
    }
  }

  /**
   * Scan IML source code and create a List of Tokens.
   *
   * @param source
   *          Source code (e.g. a file that holds iml code).
   * @return List of Tokens.
   * @throws ScannerException
   */
  public TokenList scan(final SourceCode source) throws ScannerException {
    this.reset();
    this.sourceCode = source;
    // read first Chr into cache (pos and offset both still 0):
    try {
      this.cache.addLast(this.sourceCode.next());
      // Check for BOM:
      if (this.cache.getLast().getValue() == 0xFEFF) {
        this.cache.clear();
        this.cache.addLast(this.sourceCode.next());
      } else if (this.cache.getLast().getValue() == 0xFFEF)
        throw new ScannerIOException(
            "Wrong Byte Order! First Character was U+FFEF.", null);
    } catch (final IOException e) {
      throw new ScannerIOException("Can't open file.", e);
    }
    assert this.offset == 0 && this.pos == 0;
    assert this.lineNumber == 1 && this.column == 0;
    // run through the state machine:
    while ((this.state = this.state.next(this.getCurrentChrAndMoveNext())) != null) {
      // Nothing here. The states do all the work.
    }
    this.tokens.lock();
    return this.tokens;
  }

  /** Object that gives access to all characters from the source code. */
  private SourceCode            sourceCode;
  /**
   * Absolute position of the pointer. Begins at 0, when it is set to the first
   * character.
   */
  private int                   pos        = 0;
  /** Number of the current line. Begins at 1. */
  private int                   lineNumber = 1;
  /** Number of the current column. First character on a line is at column 1. */
  private int                   column     = 0;

  /**
   * Offset-pointer indicates how many characters at the end of the cache were
   * read but then ignored (peeked).
   */
  private int                   offset     = 0;
  /** Current state of this state machine. */
  private ScannerState          state      = null;
  /** List of Tokens which is generated by this scanner. */
  private TokenList             tokens     = null;
  /**
   * A buffer of all Chrs that were not processed ({@link #forget()} /
   * {@link #accept()}) yet. Some are Chrs that have been peeked.
   */
  private final LinkedList<Chr> cache      = new LinkedList<>();

  /**
   * Accept a given Token, which has to match the lexem that is in the
   * cache.
   *
   * @see #accept()
   */
  public void accept(final DistinctToken<?> acc) {
    final List<Chr> lexem = this.getCurrentLexem();
    assert (acc.getTerminal() == Terminal.SENTINEL && this.cache.get(0).isEOF())
        || (acc.getTerminal() == Terminal.LITERAL && acc.getAttribute() instanceof AttrStrVal)
        || acc.equals(DistinctToken.getToken(lexem)) : acc.toString() + " ≠ "
        + Arrays.toString(this.cache.toArray());
    this.tokens.add(acc, this.lineNumber, this.column - lexem.size() + 1);
    this.forget();
  }

  /**
   * Accept the last read lexem, by making a token of it and adding it to the
   * Token-List. The lexem consists of the characters that were
   * read since the lest time {@link #forget()} or {@link #accept()} was called,
   * minus those that are to be ignored because {@link #movePrevChr()} was
   * called.
   *
   * @param acc
   */
  public void accept() {
    final List<Chr> lexem = this.getCurrentLexem();
    try {
      this.accept(DistinctToken.getToken(lexem));
    } catch (final SyntaxException e) {
      throw e;
    } catch (final InvalidEscapeSequenceException e) {
      throw e;
    } catch (final Throwable t) {
      throw new SyntaxException("Illegal lexem: " + Chr.toString(lexem));
    }
  }

  /**
   * List of {@link Chr}s that are the last read lexem, as it can be accepted.
   */
  private List<Chr> getCurrentLexem() {
    return this.cache.subList(0, this.cache.size() - 1 - this.offset);
  }

  /**
   * Reset the state machine. This deletes everything so that a new
   * {@link SourceCode} can be scanned.
   */
  private void reset() {
    this.cache.clear();
    this.state = ScannerState.getStartState();
    this.sourceCode = null;
    this.tokens = new TokenList();
    this.pos = 0;
    this.offset = 0;
    this.lineNumber = 1;
    this.column = 0;
  }

  /**
   * Forget all {@link Chr}s read since last {@link #accept()}.
   * The pointers {@link #pos} and {@link #offset} are not altered in
   * any way.
   */
  public void forget() {
    // delete all Chrs, except those after offset:
    final int x = this.cache.size() - 1 - this.offset;
    for (int i = 0; i < x; i++)
      this.cache.removeFirst();
  }

  /**
   * Puts pointer back by one {@link Chr}.
   *
   * @see #forget()
   */
  public void movePrevChr() {
    this.pos--;
    this.column--;
    this.offset++;
  }

  /**
   * Increments the source code pointer to the next Chr.
   * */
  private void moveNextChr() {
    if (this.offset > 0) {
      this.offset--;
    } else {
      try {
        this.cache.addLast(this.sourceCode.next());
      } catch (final IOException e) {
        throw new ScannerIOException("Can't read next character at "
            + this.getSourceCodePosition() + ".", e);
      }
    }
    this.pos++;
    this.column++;
  }

  /**
   * Returns the current Chr. This does not alter the pointer.
   *
   * @return Current Chr or -1 if end of file is reached.
   */
  private Chr getCurrentChr() {
    if (this.offset == 0) return this.cache.getLast();
    return this.cache.get(this.cache.size() - 1 - this.offset);
  }

  /**
   * Both {@link #getCurrentChr()} and then {@link #moveNextChr()} are called.
   *
   * @return The Chr from {@link #getCurrentChr()}, before
   *         {@link #moveNextChr()} is called.
   */
  private Chr getCurrentChrAndMoveNext() {
    final Chr chr = this.getCurrentChr();
    this.moveNextChr();
    return chr;
  }

  /**
   * Returns the source code pointer position.
   */
  public int getSourceCodePosition() {
    return this.pos;
  }

  /**
   * Line number of the current lexem. A lexem can never be on more than one
   * line.
   */
  @Override
  public int getLineNumber() {
    return this.lineNumber;
  }

  /** Collumn of the beginning of the current lexem. */
  @Override
  public int getColumn() {
    return this.column - this.getCurrentLexem().size() + 1;
  }

  public static void main(final String[] args) {
    if (args.length > 0) {
      final File file = new File(args[0]);
      Charset charset = FileSourceCode.DEFAULT_CHARSET;
      if (args.length >= 2) charset = Charset.forName(args[1]);

      try (final SourceCode src = new FileSourceCode(file, charset)) {
        final TokenList tokenList = SCANNER.scan(src);
        System.out.println("OUTPUT:\t" + tokenList.toString());
      } catch (final FileNotFoundException e) {
        System.err.println("File not found!");
      } catch (final ScannerException e) {
        System.out.println(e.getMessage());
      } catch (final Throwable t) {
        t.printStackTrace();
      }
    } else {
      final Random rnd = new Random();
      final StringBuffer sb = new StringBuffer();
      String src = "while iF \n x\t y3 <= := = : < > /= (foo)! ? NOT 123abc\tdo ifCOR SENTINEL DIV LE 01 :9 ::: ==},; \n";
      for (int i = 0; i < 100000; i++) {
        sb.append(rnd.nextInt(900) + 100);
        sb.append(" ");
        sb.append(src);
      }
      src = sb.toString();
      System.out.println("char count: " + src.length());
      // System.out.println("INPUT:\t"
      // + src.replace('\r', '¤').replace('\n', '¶').replace('\t', '→'));
      final long start = System.currentTimeMillis();
      // Tab would be \u21E5 but most fonts can't display that.
      TokenList tokenList;
      try {
        tokenList = SCANNER.scan(src);
        // System.out.println("OUTPUT:\t" + tokenList.toString());
        System.out.println("token count: " + tokenList.size());
      } catch (final ScannerException e) {
        System.out.println(e.getMessage());
      } catch (final Throwable t) {
        t.printStackTrace();
      }

      final long timediff = System.currentTimeMillis() - start;
      System.out.println("total time in ms: " + timediff);
      System.out.println("µs per chr: " + (timediff / (src.length() / 1000d)));
    }

    System.exit(0);
  }

  /**
   * A line break was read (second to last read character).
   * Two characters are read (peeked at) because a line break can consist of up
   * to two characters.
   * */
  public void setLineBreak() {
    Chr c = null;
    assert (c = this.cache.get(this.cache.size() - 2 - this.offset)) != null;
    assert (c.getValue() == '\r' || c.getValue() == '\n') : "Not a line break: "
        + c.getUnicodeData();
    this.lineNumber++;
    // column is set to 0 since the first character will be read later.
    this.column = 0;
  }

  /**
   * Used for the special case, where \r\n is read, and \n should not be
   * considered the first character of the new line.
   *
   * @see StateCarriageReturn
   */
  public void decrementColumn() {
    assert this.cache.getFirst().getValue() == '\n';
    this.column--;
  }
}
